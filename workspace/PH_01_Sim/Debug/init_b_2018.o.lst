   1              	# 1 "../init_b_2018.asm"
   1              	.text
   0              	
   0              	
   0              	
   2              	#        ENTRY            		/*  mark the first instruction to call */
   3              	.global	start
   4              	start:
   5              	.arm /*indicates that we are using the ARM instruction set */
   6              	#------standard initial code
   7              	# --- Setup interrupt / exception vectors 
   8 0000 FFFFFFEA 	      B       Reset_Handler 
   9              	/* In this version we do not use the following handlers */
  10              	###################################################################################################
  11              	#-----------Undefined_Handler: 
  12              	#      B       Undefined_Handler 
  13              	#----------SWI_Handler: 
  14              	#      B       SWI_Handler 
  15              	#----------Prefetch_Handler: 
  16              	#      B       Prefetch_Handler 
  17              	#----------Abort_Handler: 
  18              	#      B       Abort_Handler 
  19              	#         NOP      /* Reserved vector */ 
  20              	#----------IRQ_Handler: 
  21              	#      B       IRQ_Handler 
  22              	#----------FIQ_Handler: 
  23              	#      B       FIQ_Handler 
  24              	###################################################################################################
  25              	# Reset Handler:
  26              	# the processor starts executing this code after system reset       
  27              	###################################################################################################
  28              	Reset_Handler:  
  29              	#        
  30 0004 01D9A0E3 	        MOV     sp, #0x4000      /*  set up stack pointer (r13) */ 
  31              	
  32              	.extern     reversi8
  33 0008 A8519FE5 	        ldr         r5, = reversi8
  34 000c 0FE0A0E1 	        mov         lr, pc 
  35 0010 15FF2FE1 	        bx          r5 
  36              	
  37              	
  38              	stop: 	
  39 0014 FEFFFFEA 	 		B     	stop    	/*  end of program */
  40              	
  41              	###################################################################################################
  42              	#Funcion patron_volteo_arm_c
  43              	###################################################################################################
  44              	.section .text
  45              	.global patron_volteo_arm_c
  46              	patron_volteo_arm_c:
  47 0018 0DC0A0E1 		mov ip, sp
  48 001c F0EF2DE9 		stmdb sp!, {r4-r10,fp, sp, lr, pc}
****  Warning:if writeback register is in list, it must be the lowest reg in the list
  49 0020 04B04CE2 		sub fp, ip, #4
  50              		//Guardamos los parametros iniciales que vamos a modificar en otros registros
  51 0024 00A0A0E1 		mov r10,r0 //@tablero
  52 0028 0190A0E1 		mov r9,r1 //@longitud
  53              		//Inicializamos variables con las que vamos a trabajar
  54              		//SF y SC se deben leer de la pila
  55 002c D440DBE1 		ldrsb r4,[fp,#4] //SF
  56 0030 D850DBE1 		ldrsb r5,[fp,#8] //SC
  57              	
  58 0034 028084E0 		add r8,r4,r2 //FA = FA + SF
  59 0038 037085E0 		add r7,r5,r3 //CA = CA + SC
  60              		//Preparamos llamada a ficha valida, r0=tablero, r1=FA , r2=CA ,r3=@posicion_valida
  61 003c 0A00A0E1 		mov r0,r10
  62 0040 0810A0E1 		mov r1,r8
  63 0044 0720A0E1 		mov r2,r7
  64 0048 0060A0E3 		mov r6,#0 //posicion_valida=0
  65              		//strb r6,[sp,#-4]
  66 004c 04304DE2 		sub r3,sp,#4 //@posicion_valida
  67 0050 0360A0E1 		mov r6,r3 //Nos guardamos la direccion para el retorno de la llamada
  68              	
  69 0054 FEFFFFEB 		bl ficha_valida
  70              		//Volvemos de la funcion ficha_valida, casilla se encuentra en r0 y @posicion_valida en r4
  71 0058 0030D6E5 		ldrb r3,[r6]
  72 005c 010053E3 		cmp r3,#1 //posicion==1
  73 0060 0700001A 		bne no_patron
  74              		//cargamos color de la pila
  75 0064 0C60DBE5 		ldrb r6,[fp,#12] //r4=color
  76 0068 060050E1 		cmp r0,r6 //casilla==color
  77 006c 0000D9E5 		ldrb r0,[r9]
  78 0070 0500001A 		bne llamada_recursiva
  79 0074 000050E3 		cmp r0,#0 //longitud>0
  80 0078 0100A0C3 		movgt r0,#1 //PATRON_ENCONTRADO
  81 007c 0000A0D3 		movle r0,#0 //NO_HAY_PATRON
  82 0080 090000EA 		b return_patron_volteo_arm_c
  83              	
  84              	no_patron:
  85 0084 0000A0E3 		mov r0,#0
  86 0088 070000EA 		b return_patron_volteo_arm_c
  87              	
  88              	llamada_recursiva:
  89              	
  90              		//ldrb r0,[r9]	//cargamos valor de longitud
  91 008c 010080E2 		add r0,r0,#1	//*longitud=*longitud+1
  92 0090 0000C9E5 		strb r0,[r9]
  93              	
  94 0094 0A00A0E1 		mov r0,r10		//r0=@tablero
  95 0098 0910A0E1 		mov r1,r9		//r1=@longitud
  96 009c 0820A0E1 		mov r2,r8		//r2=FA
  97 00a0 0730A0E1 		mov r3,r7		//r3=CA
  98              		/*
  99              		strb r6,[sp]	//str SF
 100              		strb r5,[sp,#4] //str SC
 101              	 	strb r4,[sp,#8] //str color
 102              		*/
 103 00a4 70002DE9 		stmdb sp!, {r4-r6}
 104 00a8 FEFFFFEB 		bl patron_volteo_arm_c
 105              	
 106              	return_patron_volteo_arm_c:
 107 00ac F0AF1BE9 		ldmdb fp,{r4-r10,fp,sp,pc}
 108 00b0 1EFF2FE1 		bx lr
 109              	
 110              	###################################################################################################
 111              	
 112              	###################################################################################################
 113              	#Funcion patron_volteo_arm_arm
 114              	###################################################################################################
 115              	.section .text
 116              	.global patron_volteo_arm_arm
 117              	patron_volteo_arm_arm:
 118 00b4 0DC0A0E1 		mov ip, sp
 119 00b8 F0DF2DE9 		stmdb sp!, {r4-r10,fp,ip,lr, pc}
 120 00bc 04B04CE2 		sub fp, ip, #4
 121              		//Guardamos los parametros iniciales que vamos a modificar en otros registros
 122 00c0 00A0A0E1 		mov r10,r0 //@tablero
 123 00c4 0190A0E1 		mov r9,r1 //@longitud
 124              		//Inicializamos variables con las que vamos a trabajar
 125              		//SF y SC se deben leer de la pila
 126 00c8 D440DBE1 		ldrsb r4,[fp,#4] //SF
 127 00cc D850DBE1 		ldrsb r5,[fp,#8] //SC
 128              	
 129 00d0 028084E0 		add r8,r4,r2 //FA = FA + SF
 130 00d4 037085E0 		add r7,r5,r3 //CA = CA + SC
 131              		//Preparamos llamada a ficha valida, r0=tablero, r1=FA , r2=CA ,r3=@posicion_valida
 132 00d8 0A00A0E1 		mov r0,r10
 133 00dc 0810A0E1 		mov r1,r8
 134 00e0 0720A0E1 		mov r2,r7
 135 00e4 0060A0E3 		mov r6,#0 //posicion_valida=0
 136              		//strb r6,[sp,#-4]
 137 00e8 04304DE2 		sub r3,sp,#4 //@posicion_valida
 138 00ec 0360A0E1 		mov r6,r3 //Nos guardamos la direccion para el retorno de la llamada
 139              	
 140 00f0 FEFFFFEB 		bl ficha_valida_arm
 141              		//Volvemos de la funcion ficha_valida, casilla se encuentra en r0 y @posicion_valida en r4
 142 00f4 0030D6E5 		ldrb r3,[r6]
 143 00f8 010053E3 		cmp r3,#1 //posicion==1
 144 00fc 0700001A 		bne no_patron_arm_arm
 145              		//cargamos color de la pila
 146 0100 0C60DBE5 		ldrb r6,[fp,#12] //r4=color
 147 0104 060050E1 		cmp r0,r6 //casilla==color
 148 0108 0000D9E5 		ldrb r0,[r9]
 149 010c 0500001A 		bne llamada_recursiva_arm_arm
 150 0110 000050E3 		cmp r0,#0 //longitud>0
 151 0114 0100A0C3 		movgt r0,#1 //PATRON_ENCONTRADO
 152 0118 0000A0D3 		movle r0,#0 //NO_HAY_PATRON
 153 011c 090000EA 		b return_patron_volteo_arm_arm
 154              	
 155              	no_patron_arm_arm:
 156 0120 0000A0E3 		mov r0,#0
 157 0124 070000EA 		b return_patron_volteo_arm_arm
 158              	
 159              	llamada_recursiva_arm_arm:
 160              	
 161              		//ldrb r0,[r9]	//cargamos valor de longitud
 162 0128 010080E2 		add r0,r0,#1	//*longitud=*longitud+1
 163 012c 0000C9E5 		strb r0,[r9]
 164              	
 165 0130 0A00A0E1 		mov r0,r10		//r0=@tablero
 166 0134 0910A0E1 		mov r1,r9		//r1=@longitud
 167 0138 0820A0E1 		mov r2,r8		//r2=FA
 168 013c 0730A0E1 		mov r3,r7		//r3=CA
 169              		/*
 170              		strb r6,[sp]	//str SF
 171              		strb r5,[sp,#4] //str SC
 172              	 	strb r4,[sp,#8] //str color
 173              		*/
 174 0140 70002DE9 		stmdb sp!, {r4-r6}
 175 0144 FEFFFFEB 		bl patron_volteo_arm_arm
 176              	
 177              	return_patron_volteo_arm_arm:
 178 0148 F0AF1BE9 		ldmdb fp,{r4-r10,fp,sp,pc}
 179 014c 1EFF2FE1 		bx lr
 180              	
 181              	###################################################################################################
 182              	
 183              	#Funcion ficha_valida_arm
 184              	###################################################################################################
 185              	.section .text
 186              	.global ficha_valida_arm //usados: r5,r6,r7,r8
 187              	ficha_valida_arm:
 188 0150 0DC0A0E1 		mov ip, sp
 189 0154 F0DF2DE9 		stmdb sp!, {r4-r10,fp,ip, lr, pc}
 190 0158 04B04CE2 		sub fp, ip, #4
 191 015c 0850A0E3 		mov r5, #8	//r5=DIM---> como accedo a la variable??
 192 0160 0060A0E3 		mov r6, #0	//casilla vacia | valor minimo para indice de casilla
 193 0164 0170A0E3 		mov r7, #1
 194 0168 910508E0 		mul r8, r1,r5	//calculamos numero de casillas para acceso a la ficha del tablero
 195 016c 028088E0 		add r8, r8, r2	//
 196 0170 010055E1 		cmp r5,r1
 197 0174 0B0000DA 		ble no_valido	//DIM <=f
 198 0178 000051E3 		cmp r1,#0
 199 017c 090000BA 		blt no_valido	//f<0
 200 0180 020055E1 		cmp r5,r2
 201 0184 070000DA 		ble no_valido	//DIM <=c
 202 0188 070052E1 		cmp r2,r7
 203 018c 050000BA 		blt no_valido	//c<0
 204 0190 0890D0E7 		ldrb r9,[r0,r8]	//cargo en r9 tablero[f][c]--> multiplicar por 4
 205 0194 060059E1 		cmp r9,r6 //tablero[f][c] != casilla_vacia
 206 0198 0200000A 		beq no_valido
 207 019c 0070C3E5 		strb r7,[r3]
 208 01a0 0900A0E1 	 	mov r0,r9 //ficha =tablero[f][c]
 209 01a4 010000EA 	 	b retorno
 210              	
 211              	no_valido:
 212 01a8 0060C3E5 		strb r6,[r3]
 213 01ac 0600A0E1 		mov r0,r6
 214              	
 215              	retorno:
 216 01b0 F0AF1BE9 		ldmdb fp,{r4-r10,fp,sp,pc}
 217 01b4 1EFF2FE1 		bx lr
 218              	###################################################################################################
 219              	
 220              	
 221              	.data
 222              	
 223              	
 224              	
 225              	.end
DEFINED SYMBOLS
  ../init_b_2018.asm:4      .text:00000000 start
  ../init_b_2018.asm:28     .text:00000004 Reset_Handler
  ../init_b_2018.asm:8      .text:00000000 $a
  ../init_b_2018.asm:38     .text:00000014 stop
  ../init_b_2018.asm:46     .text:00000018 patron_volteo_arm_c
  ../init_b_2018.asm:84     .text:00000084 no_patron
  ../init_b_2018.asm:88     .text:0000008c llamada_recursiva
  ../init_b_2018.asm:106    .text:000000ac return_patron_volteo_arm_c
  ../init_b_2018.asm:117    .text:000000b4 patron_volteo_arm_arm
  ../init_b_2018.asm:187    .text:00000150 ficha_valida_arm
  ../init_b_2018.asm:155    .text:00000120 no_patron_arm_arm
  ../init_b_2018.asm:159    .text:00000128 llamada_recursiva_arm_arm
  ../init_b_2018.asm:177    .text:00000148 return_patron_volteo_arm_arm
  ../init_b_2018.asm:211    .text:000001a8 no_valido
  ../init_b_2018.asm:215    .text:000001b0 retorno
  ../init_b_2018.asm:221    .text:000001b8 $d
                   .debug_aranges:0000000c $d

UNDEFINED SYMBOLS
reversi8
ficha_valida
