   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer2.c"
  21              	.Ltext0:
  22              		.file 1 "../timer2.c"
 1880              		.align	2
 1881              		.global	timer2_ISR
 1883              	timer2_ISR:
 1884              	.LFB0:
   1:../timer2.c   **** /*********************************************************************************************
   2:../timer2.c   **** * Fichero:		timer2.c
   3:../timer2.c   **** * Descrip:		funciones de control del timer2 del s3c44b0x
   4:../timer2.c   **** * Version: 1.0
   5:../timer2.c   **** *********************************************************************************************/
   6:../timer2.c   **** 
   7:../timer2.c   **** /*--- ficheros de cabecera ---*/
   8:../timer2.c   **** #include "timer2.h"
   9:../timer2.c   **** #include "44b.h"
  10:../timer2.c   **** #include "44blib.h"
  11:../timer2.c   **** 
  12:../timer2.c   **** /*--- variables globales ---*/
  13:../timer2.c   **** volatile unsigned int timer2_num_int;
  14:../timer2.c   **** 
  15:../timer2.c   **** /* declaración de función que es rutina de servicio de interrupción
  16:../timer2.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  17:../timer2.c   **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  18:../timer2.c   **** 
  19:../timer2.c   **** /*--- codigo de las funciones ---*/
  20:../timer2.c   **** /* Rutina de servicio de interrupción para timer2 */
  21:../timer2.c   **** void timer2_ISR(void)
  22:../timer2.c   **** {
 1885              		.loc 1 22 0
 1886              		.cfi_startproc
 1887              		@ Interrupt Service Routine.
 1888              		@ args = 0, pretend = 0, frame = 0
 1889              		@ frame_needed = 1, uses_anonymous_args = 0
 1890 0000 04C02DE5 		str	ip, [sp, #-4]!
 1891 0004 0DC0A0E1 		mov	ip, sp
 1892              	.LCFI0:
 1893              		.cfi_def_cfa_register 12
 1894 0008 0CD82DE9 		stmfd	sp!, {r2, r3, fp, ip, lr, pc}
 1895 000c 04B04CE2 		sub	fp, ip, #4
 1896              		.cfi_offset 14, -8
 1897              		.cfi_offset 13, -12
 1898              		.cfi_offset 11, -16
 1899              		.cfi_offset 3, -20
 1900              		.cfi_offset 2, -24
 1901              	.LCFI1:
 1902              		.cfi_def_cfa 11, 4
  23:../timer2.c   **** 	timer2_num_int++;
 1903              		.loc 1 23 0
 1904 0010 30309FE5 		ldr	r3, .L2
 1905 0014 003093E5 		ldr	r3, [r3, #0]
 1906 0018 012083E2 		add	r2, r3, #1
 1907 001c 24309FE5 		ldr	r3, .L2
 1908 0020 002083E5 		str	r2, [r3, #0]
  24:../timer2.c   **** 
  25:../timer2.c   **** 	/* borrar bit en I_ISPC para desactivar la solicitud de interrupción*/
  26:../timer2.c   **** 	rI_ISPC |= BIT_TIMER2; // BIT_TIMER2 está definido en 44b.h y pone un uno en el bit 11 que correpo
 1909              		.loc 1 26 0
 1910 0024 20309FE5 		ldr	r3, .L2+4
 1911 0028 1C209FE5 		ldr	r2, .L2+4
 1912 002c 002092E5 		ldr	r2, [r2, #0]
 1913 0030 022B82E3 		orr	r2, r2, #2048
 1914 0034 002083E5 		str	r2, [r3, #0]
  27:../timer2.c   **** }
 1915              		.loc 1 27 0
 1916 0038 14D04BE2 		sub	sp, fp, #20
 1917 003c 0C689DE8 		ldmfd	sp, {r2, r3, fp, sp, lr}
 1918 0040 04C09DE4 		ldmfd	sp!, {ip}
 1919 0044 04F05EE2 		subs	pc, lr, #4
 1920              	.L3:
 1921              		.align	2
 1922              	.L2:
 1923 0048 00000000 		.word	timer2_num_int
 1924 004c 2400E001 		.word	31457316
 1925              		.cfi_endproc
 1926              	.LFE0:
 1928              		.align	2
 1929              		.global	timer2_inicializar
 1931              	timer2_inicializar:
 1932              	.LFB1:
  28:../timer2.c   **** 
  29:../timer2.c   **** /* Función que inicializa el timer2, dejandolo listo para empezar la cuenta con timer2_empezar() */
  30:../timer2.c   **** void timer2_inicializar(void)
  31:../timer2.c   **** {
 1933              		.loc 1 31 0
 1934              		.cfi_startproc
 1935              		@ Function supports interworking.
 1936              		@ args = 0, pretend = 0, frame = 0
 1937              		@ frame_needed = 1, uses_anonymous_args = 0
 1938 0050 0DC0A0E1 		mov	ip, sp
 1939              	.LCFI2:
 1940              		.cfi_def_cfa_register 12
 1941 0054 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1942 0058 04B04CE2 		sub	fp, ip, #4
 1943              		.cfi_offset 14, -8
 1944              		.cfi_offset 13, -12
 1945              		.cfi_offset 11, -16
 1946              	.LCFI3:
 1947              		.cfi_def_cfa 11, 4
  32:../timer2.c   **** 	/* Configuraion controlador de interrupciones */
  33:../timer2.c   **** 	rINTMOD = 0x0; // Configura las linas como de tipo IRQ
 1948              		.loc 1 33 0
 1949 005c 80309FE5 		ldr	r3, .L5
 1950 0060 0020A0E3 		mov	r2, #0
 1951 0064 002083E5 		str	r2, [r3, #0]
  34:../timer2.c   **** 	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 1952              		.loc 1 34 0
 1953 0068 1E36A0E3 		mov	r3, #31457280
 1954 006c 0120A0E3 		mov	r2, #1
 1955 0070 002083E5 		str	r2, [r3, #0]
  35:../timer2.c   **** 	rINTMSK &= ~(BIT_TIMER2); // habilitamos en vector de mascaras de interrupcion el Timer2 (bits 26 
 1956              		.loc 1 35 0
 1957 0074 6C309FE5 		ldr	r3, .L5+4
 1958 0078 68209FE5 		ldr	r2, .L5+4
 1959 007c 002092E5 		ldr	r2, [r2, #0]
 1960 0080 022BC2E3 		bic	r2, r2, #2048
 1961 0084 002083E5 		str	r2, [r3, #0]
  36:../timer2.c   **** 
  37:../timer2.c   **** 	/* Establece la rutina de servicio para TIMER2 */
  38:../timer2.c   **** 	pISR_TIMER2 = (unsigned) timer2_ISR;
 1962              		.loc 1 38 0
 1963 0088 5C309FE5 		ldr	r3, .L5+8
 1964 008c 5C209FE5 		ldr	r2, .L5+12
 1965 0090 002083E5 		str	r2, [r3, #0]
  39:../timer2.c   **** 
  40:../timer2.c   **** 	/* Configura el Timer2 */
  41:../timer2.c   **** 	rTCFG0 = 0x00000100; // Preescalado del timer2 en bits [15:8] de TCFG0
 1966              		.loc 1 41 0
 1967 0094 58309FE5 		ldr	r3, .L5+16
 1968 0098 012CA0E3 		mov	r2, #256
 1969 009c 002083E5 		str	r2, [r3, #0]
  42:../timer2.c   **** 
  43:../timer2.c   **** 	/*****************************************
  44:../timer2.c   **** 	 * Bits de seleccion del MUX timer 2:	 *
  45:../timer2.c   **** 	 * 1/2 -> 0000	1/4-> 0001				 *
  46:../timer2.c   **** 	 * 1/8 -> 0010	1/16-> 0011	1/32 -> 0100 *
  47:../timer2.c   **** 	 *****************************************/
  48:../timer2.c   **** 	rTCFG1 = rTCFG1 & 0xfffff0ff; // Selección del mux para el divisor de frecuencia, bits [11:8] para
 1970              		.loc 1 48 0
 1971 00a0 50309FE5 		ldr	r3, .L5+20
 1972 00a4 4C209FE5 		ldr	r2, .L5+20
 1973 00a8 002092E5 		ldr	r2, [r2, #0]
 1974 00ac 0F2CC2E3 		bic	r2, r2, #3840
 1975 00b0 002083E5 		str	r2, [r3, #0]
  49:../timer2.c   **** 	rTCNTB2 = 65535;// valor inicial de cuenta (la cuenta es descendente)
 1976              		.loc 1 49 0
 1977 00b4 40309FE5 		ldr	r3, .L5+24
 1978 00b8 40209FE5 		ldr	r2, .L5+28
 1979 00bc 002083E5 		str	r2, [r3, #0]
  50:../timer2.c   **** 	rTCMPB2 = 0 ;// valor de comparación (valor original 12800)
 1980              		.loc 1 50 0
 1981 00c0 3C309FE5 		ldr	r3, .L5+32
 1982 00c4 0020A0E3 		mov	r2, #0
 1983 00c8 002083E5 		str	r2, [r3, #0]
  51:../timer2.c   **** 	//Timer control register, para timer2 bits [15:12] -> [15] auto-reload, [14] output inverter, [13]
  52:../timer2.c   **** 	/* establecer update=manual (bit 13), inverter=off (0 en bit 14)*/
  53:../timer2.c   **** 	rTCON = 0x00002000;
 1984              		.loc 1 53 0
 1985 00cc 34309FE5 		ldr	r3, .L5+36
 1986 00d0 022AA0E3 		mov	r2, #8192
 1987 00d4 002083E5 		str	r2, [r3, #0]
  54:../timer2.c   **** }
 1988              		.loc 1 54 0
 1989 00d8 0CD04BE2 		sub	sp, fp, #12
 1990 00dc 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1991 00e0 1EFF2FE1 		bx	lr
 1992              	.L6:
 1993              		.align	2
 1994              	.L5:
 1995 00e4 0800E001 		.word	31457288
 1996 00e8 0C00E001 		.word	31457292
 1997 00ec 4CFF7F0C 		.word	209715020
 1998 00f0 00000000 		.word	timer2_ISR
 1999 00f4 0000D501 		.word	30736384
 2000 00f8 0400D501 		.word	30736388
 2001 00fc 2400D501 		.word	30736420
 2002 0100 FFFF0000 		.word	65535
 2003 0104 2800D501 		.word	30736424
 2004 0108 0800D501 		.word	30736392
 2005              		.cfi_endproc
 2006              	.LFE1:
 2008              		.align	2
 2009              		.global	timer2_empezar
 2011              	timer2_empezar:
 2012              	.LFB2:
  55:../timer2.c   **** 
  56:../timer2.c   **** /* Funcion que inicia la cuenta mediante timer2*/
  57:../timer2.c   **** void timer2_empezar(void)
  58:../timer2.c   **** {
 2013              		.loc 1 58 0
 2014              		.cfi_startproc
 2015              		@ Function supports interworking.
 2016              		@ args = 0, pretend = 0, frame = 0
 2017              		@ frame_needed = 1, uses_anonymous_args = 0
 2018 010c 0DC0A0E1 		mov	ip, sp
 2019              	.LCFI4:
 2020              		.cfi_def_cfa_register 12
 2021 0110 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2022 0114 04B04CE2 		sub	fp, ip, #4
 2023              		.cfi_offset 14, -8
 2024              		.cfi_offset 13, -12
 2025              		.cfi_offset 11, -16
 2026              	.LCFI5:
 2027              		.cfi_def_cfa 11, 4
  59:../timer2.c   **** 	// Reiniciar variable contador
  60:../timer2.c   **** 	timer2_num_int=0;
 2028              		.loc 1 60 0
 2029 0118 1C309FE5 		ldr	r3, .L8
 2030 011c 0020A0E3 		mov	r2, #0
 2031 0120 002083E5 		str	r2, [r3, #0]
  61:../timer2.c   **** 	//Reiniciar registro intermedio
  62:../timer2.c   **** 	//rTCNTO2 = 0;
  63:../timer2.c   **** 	/* iniciar timer2 (bit 12) y auto-reload (bit 15)*/
  64:../timer2.c   **** 	rTCON = 0x00009000;
 2032              		.loc 1 64 0
 2033 0124 14309FE5 		ldr	r3, .L8+4
 2034 0128 092AA0E3 		mov	r2, #36864
 2035 012c 002083E5 		str	r2, [r3, #0]
  65:../timer2.c   **** }
 2036              		.loc 1 65 0
 2037 0130 0CD04BE2 		sub	sp, fp, #12
 2038 0134 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2039 0138 1EFF2FE1 		bx	lr
 2040              	.L9:
 2041              		.align	2
 2042              	.L8:
 2043 013c 00000000 		.word	timer2_num_int
 2044 0140 0800D501 		.word	30736392
 2045              		.cfi_endproc
 2046              	.LFE2:
 2048              		.align	2
 2049              		.global	timer2_leer
 2051              	timer2_leer:
 2052              	.LFB3:
  66:../timer2.c   **** /* Funcion que obtiene el tiempo en microsegundos que se ha contado mediante el timer2.
  67:../timer2.c   ****  * Para obtener el tiempo sumaremos las veces que se ha realizado la resta con la fraccion de resta
  68:../timer2.c   ****  * que queda en el momento de leer. Este resultado le dividiremos la frecuencia de reloj en Mhz par
  69:../timer2.c   ****  * microsegundos. En este caso la frecuencia es 64Mhz y le aplicamos un divisor 1/2, con lo que ten
  70:../timer2.c   ****  * que dividir entre 32. La operación resultante es (timer2_num_int+(rTCNTB2-rTCNTO2/rTCNTB2))/(fre
  71:../timer2.c   ****  */
  72:../timer2.c   **** unsigned int timer2_leer()
  73:../timer2.c   **** {
 2053              		.loc 1 73 0
 2054              		.cfi_startproc
 2055              		@ Function supports interworking.
 2056              		@ args = 0, pretend = 0, frame = 16
 2057              		@ frame_needed = 1, uses_anonymous_args = 0
 2058 0144 0DC0A0E1 		mov	ip, sp
 2059              	.LCFI6:
 2060              		.cfi_def_cfa_register 12
 2061 0148 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2062 014c 04B04CE2 		sub	fp, ip, #4
 2063              		.cfi_offset 14, -8
 2064              		.cfi_offset 13, -12
 2065              		.cfi_offset 11, -16
 2066              	.LCFI7:
 2067              		.cfi_def_cfa 11, 4
 2068 0150 10D04DE2 		sub	sp, sp, #16
  74:../timer2.c   **** 	//unsigned int cuenta=(rTCNTB2*(timer2_num_int+((rTCNTB2-rTCNTO2))/rTCNTB2))/32;
  75:../timer2.c   **** 	unsigned int cuenta1 = (rTCNTB2)*timer2_num_int;
 2069              		.loc 1 75 0
 2070 0154 58309FE5 		ldr	r3, .L11
 2071 0158 003093E5 		ldr	r3, [r3, #0]
 2072 015c 54209FE5 		ldr	r2, .L11+4
 2073 0160 002092E5 		ldr	r2, [r2, #0]
 2074 0164 920303E0 		mul	r3, r2, r3
 2075 0168 10300BE5 		str	r3, [fp, #-16]
  76:../timer2.c   **** 	unsigned int cuenta2 = (rTCNTB2-rTCNTO2);
 2076              		.loc 1 76 0
 2077 016c 40309FE5 		ldr	r3, .L11
 2078 0170 002093E5 		ldr	r2, [r3, #0]
 2079 0174 40309FE5 		ldr	r3, .L11+8
 2080 0178 003093E5 		ldr	r3, [r3, #0]
 2081 017c 023063E0 		rsb	r3, r3, r2
 2082 0180 14300BE5 		str	r3, [fp, #-20]
  77:../timer2.c   **** 	unsigned int cuenta3 = cuenta1+cuenta2;
 2083              		.loc 1 77 0
 2084 0184 10201BE5 		ldr	r2, [fp, #-16]
 2085 0188 14301BE5 		ldr	r3, [fp, #-20]
 2086 018c 033082E0 		add	r3, r2, r3
 2087 0190 18300BE5 		str	r3, [fp, #-24]
  78:../timer2.c   **** 	unsigned int res = cuenta3/32;
 2088              		.loc 1 78 0
 2089 0194 18301BE5 		ldr	r3, [fp, #-24]
 2090 0198 A332A0E1 		mov	r3, r3, lsr #5
 2091 019c 1C300BE5 		str	r3, [fp, #-28]
  79:../timer2.c   **** 	return res;
 2092              		.loc 1 79 0
 2093 01a0 1C301BE5 		ldr	r3, [fp, #-28]
  80:../timer2.c   **** }
 2094              		.loc 1 80 0
 2095 01a4 0300A0E1 		mov	r0, r3
 2096 01a8 0CD04BE2 		sub	sp, fp, #12
 2097 01ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2098 01b0 1EFF2FE1 		bx	lr
 2099              	.L12:
 2100              		.align	2
 2101              	.L11:
 2102 01b4 2400D501 		.word	30736420
 2103 01b8 00000000 		.word	timer2_num_int
 2104 01bc 2C00D501 		.word	30736428
 2105              		.cfi_endproc
 2106              	.LFE3:
 2108              		.align	2
 2109              		.global	timer2_parar
 2111              	timer2_parar:
 2112              	.LFB4:
  81:../timer2.c   **** 
  82:../timer2.c   **** /* Funcion que para el timer y devuelve el tiempo transcurrido, pero no lo reinicia*/
  83:../timer2.c   **** unsigned int timer2_parar(void)
  84:../timer2.c   **** {
 2113              		.loc 1 84 0
 2114              		.cfi_startproc
 2115              		@ Function supports interworking.
 2116              		@ args = 0, pretend = 0, frame = 0
 2117              		@ frame_needed = 1, uses_anonymous_args = 0
 2118 01c0 0DC0A0E1 		mov	ip, sp
 2119              	.LCFI8:
 2120              		.cfi_def_cfa_register 12
 2121 01c4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2122 01c8 04B04CE2 		sub	fp, ip, #4
 2123              		.cfi_offset 14, -8
 2124              		.cfi_offset 13, -12
 2125              		.cfi_offset 11, -16
 2126              	.LCFI9:
 2127              		.cfi_def_cfa 11, 4
  85:../timer2.c   **** 	/*parar timer2, desactivamos bit 12 en TCON*/
  86:../timer2.c   **** 	rTCON = rTCON & 0xffffEfff;
 2128              		.loc 1 86 0
 2129 01cc 24309FE5 		ldr	r3, .L14
 2130 01d0 20209FE5 		ldr	r2, .L14
 2131 01d4 002092E5 		ldr	r2, [r2, #0]
 2132 01d8 012AC2E3 		bic	r2, r2, #4096
 2133 01dc 002083E5 		str	r2, [r3, #0]
  87:../timer2.c   **** 	return timer2_leer();
 2134              		.loc 1 87 0
 2135 01e0 FEFFFFEB 		bl	timer2_leer
 2136 01e4 0030A0E1 		mov	r3, r0
  88:../timer2.c   **** }
 2137              		.loc 1 88 0
 2138 01e8 0300A0E1 		mov	r0, r3
 2139 01ec 0CD04BE2 		sub	sp, fp, #12
 2140 01f0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2141 01f4 1EFF2FE1 		bx	lr
 2142              	.L15:
 2143              		.align	2
 2144              	.L14:
 2145 01f8 0800D501 		.word	30736392
 2146              		.cfi_endproc
 2147              	.LFE4:
 2149              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer2.c
                            *COM*:00000004 timer2_num_int
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:1880   .text:00000000 $a
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:1883   .text:00000000 timer2_ISR
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:1923   .text:00000048 $d
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:1928   .text:00000050 $a
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:1931   .text:00000050 timer2_inicializar
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:1995   .text:000000e4 $d
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2008   .text:0000010c $a
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2011   .text:0000010c timer2_empezar
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2043   .text:0000013c $d
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2048   .text:00000144 $a
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2051   .text:00000144 timer2_leer
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2102   .text:000001b4 $d
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2108   .text:000001c0 $a
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2111   .text:000001c0 timer2_parar
C:\Users\Ivo\AppData\Local\Temp\ccWpsxgk.s:2145   .text:000001f8 $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
