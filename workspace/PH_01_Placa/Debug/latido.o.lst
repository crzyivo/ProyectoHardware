   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"latido.c"
  21              	.Ltext0:
  22              		.file 1 "../latido.c"
 1880              		.align	2
 1883              	switch_leds_l:
 1884 0000 00000000 		.space	4
 1885              		.global	n_interrupt
 1886              		.align	2
 1889              	n_interrupt:
 1890 0004 00000000 		.space	4
 1891              		.global	en_espera
 1892              		.align	2
 1895              	en_espera:
 1896 0008 00000000 		.space	4
 1897              		.global	cuenta_espera
 1898              		.align	2
 1901              	cuenta_espera:
 1902 000c 00000000 		.space	4
 1903              		.global	espera
 1904              		.data
 1905              		.align	2
 1908              	espera:
 1909 0000 33000000 		.word	51
 1910              		.comm	funcion_callback,4,4
 1911              		.text
 1912              		.align	2
 1913              		.global	latido_ISR
 1915              	latido_ISR:
 1916              	.LFB0:
   1:../latido.c   **** /*********************************************************************************************
   2:../latido.c   **** * Fichero:		timer2.c
   3:../latido.c   **** * Autores:		Yasmina Albero e Iván Escuín
   4:../latido.c   **** * Descrip:		funciones de control del timer2 del s3c44b0x
   5:../latido.c   **** * Version: 1.0
   6:../latido.c   **** *********************************************************************************************/
   7:../latido.c   **** 
   8:../latido.c   **** /*--- ficheros de cabecera ---*/
   9:../latido.c   **** 
  10:../latido.c   **** #include "44b.h"
  11:../latido.c   **** #include "44blib.h"
  12:../latido.c   **** #include "latido.h"
  13:../latido.c   **** 
  14:../latido.c   **** /*--- variables globales ---*/
  15:../latido.c   **** volatile unsigned int n_interrupt=0;
  16:../latido.c   **** int switch_leds_l = 0;
  17:../latido.c   **** 
  18:../latido.c   **** //Variables para la gestion de esperas de rebotes
  19:../latido.c   **** int en_espera = 0;
  20:../latido.c   **** int cuenta_espera = 0;
  21:../latido.c   **** int espera = 51; //Como solo se cuentan 50 interrupciones, a 51 nunca llega
  22:../latido.c   **** 
  23:../latido.c   **** //Funcion de callback para las esperas de retardo
  24:../latido.c   **** void (*funcion_callback)(void);
  25:../latido.c   **** 
  26:../latido.c   **** /* declaración de función que es rutina de servicio de interrupción
  27:../latido.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  28:../latido.c   **** void latido_ISR(void) __attribute__((interrupt("IRQ")));
  29:../latido.c   **** 
  30:../latido.c   **** /*--- codigo de las funciones ---*/
  31:../latido.c   **** /* Rutina de servicio de interrupción para timer2 */
  32:../latido.c   **** void latido_ISR(void)
  33:../latido.c   **** {
 1917              		.loc 1 33 0
 1918              		.cfi_startproc
 1919              		@ Interrupt Service Routine.
 1920              		@ args = 0, pretend = 0, frame = 8
 1921              		@ frame_needed = 1, uses_anonymous_args = 0
 1922 0000 04C02DE5 		str	ip, [sp, #-4]!
 1923 0004 0DC0A0E1 		mov	ip, sp
 1924              	.LCFI0:
 1925              		.cfi_def_cfa_register 12
 1926 0008 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 1927 000c 04B04CE2 		sub	fp, ip, #4
 1928              		.cfi_offset 14, -8
 1929              		.cfi_offset 13, -12
 1930              		.cfi_offset 11, -16
 1931              		.cfi_offset 3, -20
 1932              		.cfi_offset 2, -24
 1933              		.cfi_offset 1, -28
 1934              		.cfi_offset 0, -32
 1935              	.LCFI1:
 1936              		.cfi_def_cfa 11, 4
 1937 0010 08D04DE2 		sub	sp, sp, #8
  34:../latido.c   **** #ifndef EMU
  35:../latido.c   **** 	switch_leds_l ++;
 1938              		.loc 1 35 0
 1939 0014 08319FE5 		ldr	r3, .L8
 1940 0018 003093E5 		ldr	r3, [r3, #0]
 1941 001c 012083E2 		add	r2, r3, #1
 1942 0020 FC309FE5 		ldr	r3, .L8
 1943 0024 002083E5 		str	r2, [r3, #0]
  36:../latido.c   **** 	if(en_espera){ // Si estoy esperando ticks, aumento la cuenta
 1944              		.loc 1 36 0
 1945 0028 F8309FE5 		ldr	r3, .L8+4
 1946 002c 003093E5 		ldr	r3, [r3, #0]
 1947 0030 000053E3 		cmp	r3, #0
 1948 0034 0400000A 		beq	.L2
  37:../latido.c   **** 		cuenta_espera++;
 1949              		.loc 1 37 0
 1950 0038 EC309FE5 		ldr	r3, .L8+8
 1951 003c 003093E5 		ldr	r3, [r3, #0]
 1952 0040 012083E2 		add	r2, r3, #1
 1953 0044 E0309FE5 		ldr	r3, .L8+8
 1954 0048 002083E5 		str	r2, [r3, #0]
 1955              	.L2:
  38:../latido.c   **** 	}
  39:../latido.c   **** 	if(cuenta_espera == espera){ //Compruebo si he esperado los ticks suficientes
 1956              		.loc 1 39 0
 1957 004c D8309FE5 		ldr	r3, .L8+8
 1958 0050 002093E5 		ldr	r2, [r3, #0]
 1959 0054 D4309FE5 		ldr	r3, .L8+12
 1960 0058 003093E5 		ldr	r3, [r3, #0]
 1961 005c 030052E1 		cmp	r2, r3
 1962 0060 0C00001A 		bne	.L3
  40:../latido.c   **** 		//Reseteo los contadores y llamo a la funcion de callback
  41:../latido.c   **** 		espera=51;
 1963              		.loc 1 41 0
 1964 0064 C4309FE5 		ldr	r3, .L8+12
 1965 0068 3320A0E3 		mov	r2, #51
 1966 006c 002083E5 		str	r2, [r3, #0]
  42:../latido.c   **** 		en_espera=0;
 1967              		.loc 1 42 0
 1968 0070 B0309FE5 		ldr	r3, .L8+4
 1969 0074 0020A0E3 		mov	r2, #0
 1970 0078 002083E5 		str	r2, [r3, #0]
  43:../latido.c   **** 		cuenta_espera=0;
 1971              		.loc 1 43 0
 1972 007c A8309FE5 		ldr	r3, .L8+8
 1973 0080 0020A0E3 		mov	r2, #0
 1974 0084 002083E5 		str	r2, [r3, #0]
  44:../latido.c   **** 		funcion_callback();
 1975              		.loc 1 44 0
 1976 0088 A4309FE5 		ldr	r3, .L8+16
 1977 008c 003093E5 		ldr	r3, [r3, #0]
 1978 0090 0FE0A0E1 		mov	lr, pc
 1979 0094 13FF2FE1 		bx	r3
 1980              	.L3:
  45:../latido.c   **** 	}
  46:../latido.c   **** 	int aux=switch_leds_l;
 1981              		.loc 1 46 0
 1982 0098 84309FE5 		ldr	r3, .L8
 1983 009c 003093E5 		ldr	r3, [r3, #0]
 1984 00a0 20300BE5 		str	r3, [fp, #-32]
  47:../latido.c   **** 
  48:../latido.c   **** 	if(switch_leds_l == 24){
 1985              		.loc 1 48 0
 1986 00a4 78309FE5 		ldr	r3, .L8
 1987 00a8 003093E5 		ldr	r3, [r3, #0]
 1988 00ac 180053E3 		cmp	r3, #24
 1989 00b0 0000001A 		bne	.L4
 1990              	.LBB2:
  49:../latido.c   **** 		led1_on();
 1991              		.loc 1 49 0
 1992 00b4 FEFFFFEB 		bl	led1_on
 1993              	.L4:
 1994              	.LBE2:
  50:../latido.c   **** 	}
  51:../latido.c   **** 	if(switch_leds_l == 25){
 1995              		.loc 1 51 0
 1996 00b8 64309FE5 		ldr	r3, .L8
 1997 00bc 003093E5 		ldr	r3, [r3, #0]
 1998 00c0 190053E3 		cmp	r3, #25
 1999 00c4 0000001A 		bne	.L5
 2000              	.LBB3:
  52:../latido.c   **** 		led1_off();
 2001              		.loc 1 52 0
 2002 00c8 FEFFFFEB 		bl	led1_off
 2003              	.L5:
 2004              	.LBE3:
  53:../latido.c   **** 	}
  54:../latido.c   **** 
  55:../latido.c   **** 	if(switch_leds_l==49){
 2005              		.loc 1 55 0
 2006 00cc 50309FE5 		ldr	r3, .L8
 2007 00d0 003093E5 		ldr	r3, [r3, #0]
 2008 00d4 310053E3 		cmp	r3, #49
 2009 00d8 0000001A 		bne	.L6
 2010              	.LBB4:
  56:../latido.c   **** 		led1_on();
 2011              		.loc 1 56 0
 2012 00dc FEFFFFEB 		bl	led1_on
 2013              	.L6:
 2014              	.LBE4:
  57:../latido.c   **** 	}
  58:../latido.c   **** 	if(switch_leds_l==50){
 2015              		.loc 1 58 0
 2016 00e0 3C309FE5 		ldr	r3, .L8
 2017 00e4 003093E5 		ldr	r3, [r3, #0]
 2018 00e8 320053E3 		cmp	r3, #50
 2019 00ec 0300001A 		bne	.L7
 2020              	.LBB5:
  59:../latido.c   **** 		led1_off();
 2021              		.loc 1 59 0
 2022 00f0 FEFFFFEB 		bl	led1_off
  60:../latido.c   **** 		switch_leds_l=0;
 2023              		.loc 1 60 0
 2024 00f4 28309FE5 		ldr	r3, .L8
 2025 00f8 0020A0E3 		mov	r2, #0
 2026 00fc 002083E5 		str	r2, [r3, #0]
 2027              	.L7:
 2028              	.LBE5:
  61:../latido.c   **** 	}
  62:../latido.c   **** 	/* borrar bit en I_ISPC para desactivar la solicitud de interrupción*/
  63:../latido.c   **** 
  64:../latido.c   **** 	rI_ISPC |= BIT_TIMER0; // BIT_TIMER0 está definido en 44b.h y pone un uno en el bit 11 que correpo
 2029              		.loc 1 64 0
 2030 0100 30309FE5 		ldr	r3, .L8+20
 2031 0104 2C209FE5 		ldr	r2, .L8+20
 2032 0108 002092E5 		ldr	r2, [r2, #0]
 2033 010c 022A82E3 		orr	r2, r2, #8192
 2034 0110 002083E5 		str	r2, [r3, #0]
  65:../latido.c   **** #endif
  66:../latido.c   **** 
  67:../latido.c   **** }
 2035              		.loc 1 67 0
 2036 0114 1CD04BE2 		sub	sp, fp, #28
 2037 0118 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 2038 011c 04C09DE4 		ldmfd	sp!, {ip}
 2039 0120 04F05EE2 		subs	pc, lr, #4
 2040              	.L9:
 2041              		.align	2
 2042              	.L8:
 2043 0124 00000000 		.word	switch_leds_l
 2044 0128 00000000 		.word	en_espera
 2045 012c 00000000 		.word	cuenta_espera
 2046 0130 00000000 		.word	espera
 2047 0134 00000000 		.word	funcion_callback
 2048 0138 2400E001 		.word	31457316
 2049              		.cfi_endproc
 2050              	.LFE0:
 2052              		.align	2
 2053              		.global	latido_inicializar
 2055              	latido_inicializar:
 2056              	.LFB1:
  68:../latido.c   **** 
  69:../latido.c   **** /* Función que inicializa el timer2, dejandolo listo para empezar la cuenta con timer2_empezar() */
  70:../latido.c   **** void latido_inicializar(void)
  71:../latido.c   **** {
 2057              		.loc 1 71 0
 2058              		.cfi_startproc
 2059              		@ Function supports interworking.
 2060              		@ args = 0, pretend = 0, frame = 0
 2061              		@ frame_needed = 1, uses_anonymous_args = 0
 2062 013c 0DC0A0E1 		mov	ip, sp
 2063              	.LCFI2:
 2064              		.cfi_def_cfa_register 12
 2065 0140 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2066 0144 04B04CE2 		sub	fp, ip, #4
 2067              		.cfi_offset 14, -8
 2068              		.cfi_offset 13, -12
 2069              		.cfi_offset 11, -16
 2070              	.LCFI3:
 2071              		.cfi_def_cfa 11, 4
  72:../latido.c   **** #ifndef EMU
  73:../latido.c   **** 	led1_off();
 2072              		.loc 1 73 0
 2073 0148 FEFFFFEB 		bl	led1_off
  74:../latido.c   **** 	/* Configuraion controlador de interrupciones */
  75:../latido.c   **** 	rINTMOD = 0x0; // Configura las linas como de tipo IRQ
 2074              		.loc 1 75 0
 2075 014c 8C309FE5 		ldr	r3, .L11
 2076 0150 0020A0E3 		mov	r2, #0
 2077 0154 002083E5 		str	r2, [r3, #0]
  76:../latido.c   **** 	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 2078              		.loc 1 76 0
 2079 0158 1E36A0E3 		mov	r3, #31457280
 2080 015c 0120A0E3 		mov	r2, #1
 2081 0160 002083E5 		str	r2, [r3, #0]
  77:../latido.c   **** 	rINTMSK &= ~(BIT_TIMER0); // habilitamos en vector de mascaras de interrupcion el Timer2 (bits 26 
 2082              		.loc 1 77 0
 2083 0164 78309FE5 		ldr	r3, .L11+4
 2084 0168 74209FE5 		ldr	r2, .L11+4
 2085 016c 002092E5 		ldr	r2, [r2, #0]
 2086 0170 022AC2E3 		bic	r2, r2, #8192
 2087 0174 002083E5 		str	r2, [r3, #0]
  78:../latido.c   **** 
  79:../latido.c   **** 	/* Establece la rutina de servicio para TIMER2 */
  80:../latido.c   **** 	pISR_TIMER0 = (unsigned) latido_ISR;
 2088              		.loc 1 80 0
 2089 0178 68309FE5 		ldr	r3, .L11+8
 2090 017c 68209FE5 		ldr	r2, .L11+12
 2091 0180 002083E5 		str	r2, [r3, #0]
  81:../latido.c   **** 
  82:../latido.c   **** 	/* Configura el Timer0 */
  83:../latido.c   **** 	rTCFG0 = 0x00000009; // Preescalado del timer2 en bits [7:0] de TCFG0. Dividimos entre 1 para el m
 2092              		.loc 1 83 0
 2093 0184 64309FE5 		ldr	r3, .L11+16
 2094 0188 0920A0E3 		mov	r2, #9
 2095 018c 002083E5 		str	r2, [r3, #0]
  84:../latido.c   **** 
  85:../latido.c   **** 	/*****************************************
  86:../latido.c   **** 	 * Bits de seleccion del MUX timer 0:	 *
  87:../latido.c   **** 	 * 1/2 -> 0000	1/4-> 0001				 *
  88:../latido.c   **** 	 * 1/8 -> 0010	1/16-> 0011	1/32 -> 0100 *
  89:../latido.c   **** 	 *****************************************/
  90:../latido.c   **** 	rTCFG1 = rTCFG1 & 0xfffffff4; // Selección del mux para el divisor de frecuencia, bits [3:0] para 
 2096              		.loc 1 90 0
 2097 0190 5C309FE5 		ldr	r3, .L11+20
 2098 0194 58209FE5 		ldr	r2, .L11+20
 2099 0198 002092E5 		ldr	r2, [r2, #0]
 2100 019c 0B20C2E3 		bic	r2, r2, #11
 2101 01a0 002083E5 		str	r2, [r3, #0]
  91:../latido.c   **** 	rTCNTB0 = 65535;// valor inicial de cuenta (la cuenta es descendente)
 2102              		.loc 1 91 0
 2103 01a4 4C309FE5 		ldr	r3, .L11+24
 2104 01a8 4C209FE5 		ldr	r2, .L11+28
 2105 01ac 002083E5 		str	r2, [r3, #0]
  92:../latido.c   **** 	rTCMPB0 = 64535 ;// valor de comparación (valor original 12800)
 2106              		.loc 1 92 0
 2107 01b0 48309FE5 		ldr	r3, .L11+32
 2108 01b4 48209FE5 		ldr	r2, .L11+36
 2109 01b8 002083E5 		str	r2, [r3, #0]
  93:../latido.c   **** 	//Timer control register, para timer0 bits [3:0] -> [3] auto-reload, [2] output inverter, [1] manu
  94:../latido.c   **** 	/* establecer update=manual (bit 1), inverter=off (0 en bit 2)*/
  95:../latido.c   **** 	rTCON = 0x2;
 2110              		.loc 1 95 0
 2111 01bc 44309FE5 		ldr	r3, .L11+40
 2112 01c0 0220A0E3 		mov	r2, #2
 2113 01c4 002083E5 		str	r2, [r3, #0]
  96:../latido.c   **** 
  97:../latido.c   **** 	//Iniciamos el latido
  98:../latido.c   **** 	rTCON = 0x09;
 2114              		.loc 1 98 0
 2115 01c8 38309FE5 		ldr	r3, .L11+40
 2116 01cc 0920A0E3 		mov	r2, #9
 2117 01d0 002083E5 		str	r2, [r3, #0]
  99:../latido.c   **** #endif
 100:../latido.c   **** }
 2118              		.loc 1 100 0
 2119 01d4 0CD04BE2 		sub	sp, fp, #12
 2120 01d8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2121 01dc 1EFF2FE1 		bx	lr
 2122              	.L12:
 2123              		.align	2
 2124              	.L11:
 2125 01e0 0800E001 		.word	31457288
 2126 01e4 0C00E001 		.word	31457292
 2127 01e8 54FF7F0C 		.word	209715028
 2128 01ec 00000000 		.word	latido_ISR
 2129 01f0 0000D501 		.word	30736384
 2130 01f4 0400D501 		.word	30736388
 2131 01f8 0C00D501 		.word	30736396
 2132 01fc FFFF0000 		.word	65535
 2133 0200 1000D501 		.word	30736400
 2134 0204 17FC0000 		.word	64535
 2135 0208 0800D501 		.word	30736392
 2136              		.cfi_endproc
 2137              	.LFE1:
 2139              		.align	2
 2140              		.global	espera_ticks
 2142              	espera_ticks:
 2143              	.LFB2:
 101:../latido.c   **** 
 102:../latido.c   **** void espera_ticks(int ticks,void (*callback_espera)()){
 2144              		.loc 1 102 0
 2145              		.cfi_startproc
 2146              		@ Function supports interworking.
 2147              		@ args = 0, pretend = 0, frame = 8
 2148              		@ frame_needed = 1, uses_anonymous_args = 0
 2149 020c 0DC0A0E1 		mov	ip, sp
 2150              	.LCFI4:
 2151              		.cfi_def_cfa_register 12
 2152 0210 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2153 0214 04B04CE2 		sub	fp, ip, #4
 2154              		.cfi_offset 14, -8
 2155              		.cfi_offset 13, -12
 2156              		.cfi_offset 11, -16
 2157              	.LCFI5:
 2158              		.cfi_def_cfa 11, 4
 2159 0218 08D04DE2 		sub	sp, sp, #8
 2160 021c 10000BE5 		str	r0, [fp, #-16]
 2161 0220 14100BE5 		str	r1, [fp, #-20]
 103:../latido.c   **** 	en_espera=1;
 2162              		.loc 1 103 0
 2163 0224 28309FE5 		ldr	r3, .L14
 2164 0228 0120A0E3 		mov	r2, #1
 2165 022c 002083E5 		str	r2, [r3, #0]
 104:../latido.c   **** 	funcion_callback = callback_espera;
 2166              		.loc 1 104 0
 2167 0230 14201BE5 		ldr	r2, [fp, #-20]
 2168 0234 1C309FE5 		ldr	r3, .L14+4
 2169 0238 002083E5 		str	r2, [r3, #0]
 105:../latido.c   **** 	espera=ticks;
 2170              		.loc 1 105 0
 2171 023c 18309FE5 		ldr	r3, .L14+8
 2172 0240 10201BE5 		ldr	r2, [fp, #-16]
 2173 0244 002083E5 		str	r2, [r3, #0]
 106:../latido.c   **** #ifdef EMU
 107:../latido.c   **** 	funcion_callback();
 108:../latido.c   **** #endif
 109:../latido.c   **** }
 2174              		.loc 1 109 0
 2175 0248 0CD04BE2 		sub	sp, fp, #12
 2176 024c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2177 0250 1EFF2FE1 		bx	lr
 2178              	.L15:
 2179              		.align	2
 2180              	.L14:
 2181 0254 00000000 		.word	en_espera
 2182 0258 00000000 		.word	funcion_callback
 2183 025c 00000000 		.word	espera
 2184              		.cfi_endproc
 2185              	.LFE2:
 2187              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 latido.c
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1883   .bss:00000000 switch_leds_l
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1880   .bss:00000000 $d
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1889   .bss:00000004 n_interrupt
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1895   .bss:00000008 en_espera
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1901   .bss:0000000c cuenta_espera
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1908   .data:00000000 espera
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1905   .data:00000000 $d
                            *COM*:00000004 funcion_callback
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1912   .text:00000000 $a
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:1915   .text:00000000 latido_ISR
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2043   .text:00000124 $d
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2052   .text:0000013c $a
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2055   .text:0000013c latido_inicializar
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2125   .text:000001e0 $d
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2139   .text:0000020c $a
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2142   .text:0000020c espera_ticks
C:\Users\Ivo\AppData\Local\Temp\ccH1Q0AT.s:2181   .text:00000254 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
led1_on
led1_off
